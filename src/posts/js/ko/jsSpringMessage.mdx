---
title: "JS 파일에서 Spring Message Source 사용하는법"
date: "2025-12-13"
description: "Freemarker와 CDN 방식의 Vue를 사용하고 있었다. 컴포넌트 형식으로 재사용되는 소스를 .js 파일로 생성해두었는데 해외 고객이 발생했고 웹에 있는 모든 한글을 영문으로 변경이 필요했다..!"
tags: ["spring boot", "vue", "Freemarker", "Plugin Architecture"]
thumbnail: "/post/docker/thumbnail.png"
status: "complete"
---

## 문제 상황

현재 진행중인 프로젝트의 프론트엔드가 Freemarker(Server Template Engine) + CDN Vue로 구성되어 있었다.
데이터의 관리는 Vue로, 빠른 조회를 위한 서버 사이드 렌더링을 위해 Freemarker를 사용하고 있었던 것이다.

이러한 구성에서 해외 고객(싱가포르)이 발생하였고 당연히 영어 버전의 포탈이 필요하게 되었다.

영문 작업을 위해
첫 번째로 message.properties 파일을 ko, en 버전으로 생성하여 웹에서 사용하는 텍스트들을 정리하였고
MessageSource 라이브러리를 이용하여 설정된 값의 key를 읽어올 수 있도록 하였다.
하지만 `js`(정적 리소스) 파일들은 해당 문법을 사용할 수 없었다.

당연하게 `ftl` 파일들의 경우에는 Freemarker 처리가 되어 `<@spring.message "${message.key}"/>`
문법을 사용하여 한글/영어 적용이 가능했지만 `js` 템플릿 엔진을 거치지 않기 때문에 사용하지 못하는 것이였다.

해결책은 총 2가지가 존재하였다.

**1. 통합 FTL 방식**
> 하위 js 파일들을 묶는 상위 ftl 파일을 생성하여 `<@spring.message />`를 전달받는다.

**2. Build 시점에 동적으로 `message_${lang}.js` 생성**
> build 시점에 `npm property-reader`를 사용하여 정적 message_ko.js, message_en.js 파일을 생성한다.


### 1. 통합 FTL 방식

> 하위 js 파일들을 묶는 상위 ftl 파일을 생성하여 spring.message를 전달받고 `<script>`로 호출하려고 했습니다

```js title="common.ftl" {13-28}
<script src="/res/js/highcharts.js" charset="UTF-8"></script>
<script src="/res/js/data.js"></script>
<script src="/res/js/highcharts-more.js"></script>
<script src="/res/js/no-data-to-display.js"></script>
<script src="/res/js/wordcloud.js"></script>

var _ORGANIZATION_CODE_ = "${userInfo.organizationCode!''}"
var _ORGANIZATION_NAME_ = "${userInfo.organizationName!""}";
var _TEAM_NM_ = "${userInfo.teamName!''}"
var _HAS_MULTI_ORGANIZATION_ = ${userInfo.hasMultiOrganization?c}
const _DEFAULT_CPU_UNIT_ = "${cpuUnit}"

<!-- 이외에 수십개의 script및 수백개의 properties -->
```

**장점**
- 상위로 묶을 수 있는 `ftl` 파일이 존재한다면 매우 효과적인 방법이다.
- 필요한 변수에 대해서만 `<@spring.message />`를 호출하면 변수 관리와 리소스 낭비가 없다.

**단점**
- 상위로 묶이지 않는 경우 불필요한 `ftl` 파일이 생성되고 변수 관리가 어렵다.
- 모든 `js` 파일을 상위에 선언하면 하나의 컴포넌트 사용을 위해 수십개의 `<script>`를 호출하는 낭비가 발생한다.
- 개발자가 두 곳을(spring.message, ftl) 수정해야 하는 불편함이 있다.

통합 FTL 방식은 이렇게 멀리 떠나보냈다.

### 2. Build 시점 방식

두 번째 해결책은 `npm property-reader`를 사용하는 거였다.

`build.gradle` 파일에 해당 npm이 존재하지 않는다면 모듈을 다운받도록 하였고
build시에는 message_ko.properties, message_en.properties 파일을 읽어와서 message_ko.js, message_en.js 파일을 생성하여
정적 리소스파일에서도 호출이 가능하도록 만드는 것이였다.

```gradle title="build.gradle"
// 필요한 Node.js 패키지 설치 Task 정의
task setupNodeModules(type: Exec) {
description = "Node.js dependencies install (e.g., properties-reader)."
commandLine 'npm', 'install'
workingDir project.rootDir
standardOutput = System.out
errorOutput = System.err
}

// =====================================================================
// [선택적] i18n JS 파일 생성 Task (빌드 시점)
// 기본적으로 런타임에 ApplicationMessageToJsGenerator가 생성하므로 비활성화
// 필요시 gradle -PgenerateI18nAtBuild=true build로 빌드 타임 생성 가능
// =====================================================================
task generateI18nJs(type: Exec) {
description = "Generates i18n JavaScript files from properties at build time (optional)."
commandLine 'node', 'build-i18n.js'
workingDir project.rootDir
standardOutput = System.out
errorOutput = System.err
enabled = project.hasProperty('generateI18nAtBuild') && project.generateI18nAtBuild == 'true'

    doLast {
        def jsFilePath = "${project.rootDir}/clovircm-web/src/main/resources/static/res/js/i18n/messages_ko.js"
        if (!file(jsFilePath).exists()) {
            throw new GradleException("Error: i18n JS file generation failed. Check build-i18n.js and file paths.")
        }
    }
}
```

## 문제 발생 (Plugin-Architecture)

해외 고객에서 커스텀한 기능을 요청했다. 동시에 다른 고객에서도 다른 커스텀한 기능을 요청했다.
이에 대한 아키텍쳐를 설계하였고 마이크로서비스가 아닌 모놀리식 아키텍쳐이기 때문에 플러그인 아키텍쳐를 고려했다.

브랜치별로 나누는 것은 다른 개발자가 해당 고객의 브랜치의 기능을 수정할 때 유지보수/기능개발 시간이 많이 증가하기 때문에 좋은 선택이 아니였다.

플러그인 아키텍쳐는 코어 모듈과 다수의 플러그인 모듈로 구성된다.
플러그인 모듈에서는 고객의 커스터마이징된 기능, 메뉴, 메뉴에 따른 새로운 message.properties가 존재할 것이다.

<Callout type="warning">
플러그인 아키텍처에서는 웹이 배포된 이후 플러그인을 배포하는 순서인데, **플러그인 배포 이후 재빌드가 되지 않는다**는 점이 핵심 문제다.
</Callout>

그럼 빌드시점에 js 파일을 만드는 것은 불가능이 되었으니
빌드 시점에 하던 작업을 서버가 기동되는 시점으로 변경한다.
런타임에 기본적으로 1회 js 파일을 만들고, 플러그인이 등록된 경우에는 추가적으로 1회를 진행한다.

## 코드 수정

코드 수정은 매우 적은 클래스 하나로 가능하다.

1. 백엔드 소스에 저장된 `message.properties` 파일을 읽어올 수 있는 Generator
2. message.js.output.path을 loca, production에 나눠서 설정한다. (war와 local의 static 파일 경로가 다르기 때문이다.)
3. PluginLoader(플러그인 처리) DatabaseMessageSource(message_properties를 DB에 저장) 이후 후처리 작업으로 런타임시에 `js` 파일을 생성하도록 설정하면 끝이다.
4. 만들어진 js 파일을 읽어오는 helper.js

### MessageFileGenerator
```java title="MessageFileGenerator"
public class MessageFileGenerator {

    private final MessageSourceRepository messageSourceRepository;
    private static final String[] LOCALES = {"ko", "en"};
    private static final String JS_VAR_NAME = "ALL_MESSAGES";
    private static final Charset UTF_8 = StandardCharsets.UTF_8;

    @Value("${message.js.output.path}")
    private String outputDirectory;

    public void generateJsFiles() {
        List<MessageSource> sources = messageSourceRepository.findAll();
        Map<String, List<MessageSource>> groupedByLocale = sources.stream().collect(Collectors.groupingBy(MessageSource::getLocale));

        for (String locale : LOCALES) {
            try {
                String fileName = "messages_" + locale + ".js";
                Path filePath = Paths.get(outputDirectory, fileName);
                Files.createDirectories(filePath.getParent());
                Files.write(filePath, generateJsContent(groupedByLocale.get(locale)).getBytes(UTF_8));
            } catch (Exception e) {
                log.error("Failed to generate JS file for locale: {}", locale, e);
            }
        }
    }
}
```

### `message.properties` 후처리작업될 class 파일들

```java {5} {14}
@PostConstruct
    public void init() {
        if (messageSourceRepository.findAny() == null || messageReload) {
            initMessageFileToDb();
            messageFileGenerator.generateJsFiles(); // 이 부분
        } else {
            reloadToCache();
        }
    }

@PostConstruct
public void init() {
        if (pluginInstallable && pluginInfo.isPresent()) {
            if (messageReload) reloadPluginMessages(); // 이 부분
            if (menuReload) reloadPluginMenu();
        }
    }
```

### production, local의 static 파일정리

#### production

```properties
# production
message.js.output.path=${catalina.base}/webapps/ROOT/WEB-INF/classes/static/res/js/i18n
```

#### local
```properties
# local
message.js.output.path = /src/main/resources/static/res/js/i18n
```

### js 파일을 읽어오는 helper
```js
function getI18nMessage(key, args = []) {
    // FTL에서 정의한 currentLang (ko, en) 사용
    const langCode = window.currentLang ? window.currentLang.toUpperCase() : 'KO';

    // 빌드 스크립트가 생성한 전역 객체 이름 (ALL_MESSAGES_KO)
    const jsVarName = `ALL_MESSAGES_${langCode}`;
    const messages = window[jsVarName];

    if (!messages || !messages[key]) {
        return `${key}`;
    }

    let message = messages[key];

    if (args.length > 0) {

        args.forEach((arg, index) => {
            // {0}, {1}, {2} ... 를 실제 값으로 치환
            const placeholder = `{${index}}`;
            message = message.split(placeholder).join(arg);
        });
    }

    return message;
}
```

### 사용법

Vue.js의 computed 문법을 이용하여 `message.properties` 에 존재하는 동일한 키 값을 전달하여, 해당 텍스트를 변환하여 가져온다.

```js
Vue.component('create-btn', {
    props: [
      'resourceType'
    ],

    data: function(){
        return {
            createAuthority: 'ALL'
        }
    },
    computed:{
        createButtonText() {
            return getI18nMessage('requestaction.create');
        },
    template: `
        <button class="new" :disabled="createAuthority == 'NONE'" @click="goToCreateIndex()">{{ createButtonText }}</button>
        `}
    })
```

## 느낀점

처음에는 간단하게 통합 FTL을 생성하여 상위에서 호출하여 해결하려고 하였고, 성능문제가 있어 이를 포기했다.
그 후 build 시점에서 `npm module`을 이용해서 해결하려고 하였고 플러그인 아키텍처의 도입으로 인해 이것도 포기했다.

세 가지 방식을 시도하면서 빌드타임과 런타임 생성의 차이를 제대로 이해하게 됐다.
빌드 시점 생성이 더 깔끔해 보였지만, 플러그인처럼 동적으로 변경되는 환경에서는 런타임 생성이 훨씬 유연한 선택이었다.

마지막으로 런타임에 실행시키는 방법을 택했는데 어떻게 보면 처음부터 이렇게 설계할 수 있었지 않을까 싶다.
요구사항 정의 단계에서 "향후 플러그인이 필요할 수 있나요?"라고 물어봤다면 두 번째 시도를 건너뛸 수 있었을 것 같다.

앞으로 손이 먼저 움직이기 전에 확장성을 고려해서 코드를 작성해보는 습관을 더 들여야겠다!


